#include "ini_file.h"

#include "exception.h"
#include <memory>
#include <cstring>
#include <iostream>
#include <vector>


IniFile::IniFile(const std::string& fileName) :
    m_fileName(fileName)
{
    auto file = std::shared_ptr<FILE>(
        fopen(m_fileName.c_str(), "rb"),
        [](FILE *f) { if (f) fclose(f); });

    if (!file)
    {
        THROW_EXCEPTION("Could not open file: ", m_fileName.c_str());
    }

    std::vector<char> lineBuffer(1024);
    char* line = lineBuffer.data();
    while (fgets(line, lineBuffer.size(), file.get()))
    {
        if (line[0] == '#' || line[0] == ';') // skip comments
        {
            continue;
        }
        if (line[0] == '\n' && line[0] == '\r') // skip empty lines
        {
            continue;
        }

        // remove whitespaces
        while (*line != '\0' && (*line == ' ' || *line == '\t' || *line == '\r'))
        {
            ++line;
        }
        
        // remove trailing whitespaces
        char* end = line + strlen(line) - 1;
        while (end > line && (*end == ' ' || *end == '\t' || *end == '\r' || *end == '\n'))
        {
            --end;
        }

        *(end + 1) = '\0'; // null-terminate the string

        // find '=' character
        char* equalSign = strchr(line, '=');
        if (!equalSign)
        {
            continue; // no '=' found, skip this line
        }

        // remove whitespaces around '='
        *equalSign = '\0';
        char* keyStart = line;
        char* keyEnd = equalSign - 1;
        while (keyEnd > keyStart && (*keyEnd == ' ' || *keyEnd == '\t'))
        {
            --keyEnd;
        }
        *(keyEnd + 1) = '\0'; // null-terminate the key string
        char* valueStart = equalSign + 1;
        char* valueEnd = valueStart + strlen(valueStart) - 1;
        while (valueEnd > valueStart && (*valueEnd == ' ' || *valueEnd == '\t' || *valueEnd == '\r' || *valueEnd == '\n'))
        {
            --valueEnd;
        }
        *(valueEnd + 1) = '\0'; // null-terminate the value string

        // remove whitespaces around value
        while (*valueStart != '\0' && (*valueStart == ' ' || *valueStart == '\t'))
        {
            ++valueStart;
        }
        while (*valueEnd != '\0' && (*valueEnd == ' ' || *valueEnd == '\t'))
        {
            --valueEnd;
        }
        *(valueEnd + 1) = '\0'; // null-terminate the value string
        
        m_data[keyStart] = valueStart;
    }
}

std::optional<std::string> IniFile::getString(const std::string &key)
{

    auto it = m_data.find(key);
    if (it != m_data.end())
    {
        return it->second;
    }

    return std::nullopt;
}

void IniFile::setString(const std::string &key, const std::string &value)
{
    m_data[key] = value;
}

void IniFile::save()
{
    auto file = std::shared_ptr<FILE>(
        fopen(m_fileName.c_str(), "wb"),
        [](FILE *f) { if (f) fclose(f); });

    if (!file)
    {
        THROW_EXCEPTION("Could not open file: ", m_fileName.c_str());
    }

    fprintf(file.get(), "; File is autogenerated, do not edit!\n\n");

    for (const auto& pair : m_data)
    {
        fprintf(file.get(), "%s=%s\n", pair.first.c_str(), pair.second.c_str());
    }
}
